<!doctype html>
<html lang="pt-br">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Moldura Interativa</title>

<style>
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
    background:#f5f5f5;
    padding:16px;
  }
  .card {
    background:#fff;
    padding:14px;
    border-radius:14px;
    box-shadow:0 2px 10px rgba(0,0,0,.08);
  }
  canvas {
    display:block;
    max-width:100%;
    background:#000;
    border-radius:12px;
    margin-top:12px;
    touch-action:none;
  }
  button {
    padding:10px 14px;
    margin-top:8px;
    cursor:pointer;
  }
  .hint {
    font-size:13px;
    color:#444;
    margin-top:8px;
  }
</style>
</head>

<body>

<h2>Envie sua foto e ajuste</h2>

<div class="card">
  <input id="photo" type="file" accept="image/*"><br>
  <button id="download" disabled>Baixar imagem</button>

  <div class="hint">
    • Arraste com 1 dedo<br>
    • Use <strong>pinça com dois dedos</strong> para dar zoom e mover
  </div>

  <canvas id="canvas" width="1080" height="1920"></canvas>
</div>

<script>
const W = 1080;
const H = 1920;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const input = document.getElementById('photo');
const downloadBtn = document.getElementById('download');

const frame = new Image();
frame.src = 'frame.png';

let img = null;

// estado de transformação
let baseScale = 1;
let scale = 1;
let offsetX = 0;
let offsetY = 0;

// touch
let lastX = 0;
let lastY = 0;
let lastDist = 0;
let lastCenter = null;

// utilidades
function getCanvasScale() {
  const r = canvas.getBoundingClientRect();
  return { sx: W / r.width, sy: H / r.height };
}

function distance(t1, t2) {
  return Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
}

function center(t1, t2) {
  return {
    x: (t1.clientX + t2.clientX) / 2,
    y: (t1.clientY + t2.clientY) / 2
  };
}

function clamp() {
  const dw = img.width * baseScale * scale;
  const dh = img.height * baseScale * scale;

  if (dw > W) {
    offsetX = Math.min(0, Math.max(W - dw, offsetX));
  } else {
    offsetX = (W - dw) / 2;
  }

  if (dh > H) {
    offsetY = Math.min(0, Math.max(H - dh, offsetY));
  } else {
    offsetY = (H - dh) / 2;
  }
}

function render() {
  ctx.clearRect(0, 0, W, H);

  if (img) {
    clamp();
    ctx.drawImage(
      img,
      offsetX,
      offsetY,
      img.width * baseScale * scale,
      img.height * baseScale * scale
    );
  }

  if (frame.complete) {
    ctx.drawImage(frame, 0, 0, W, H);
  }
}

// upload
input.addEventListener('change', () => {
  const file = input.files[0];
  if (!file) return;

  const image = new Image();
  image.onload = () => {
    img = image;

    baseScale = Math.max(W / img.width, H / img.height);
    scale = 1;

    offsetX = (W - img.width * baseScale) / 2;
    offsetY = (H - img.height * baseScale) / 2;

    downloadBtn.disabled = false;
    render();
  };
  image.src = URL.createObjectURL(file);
});

// touchstart
canvas.addEventListener('touchstart', (e) => {
  if (!img) return;
  e.preventDefault();

  if (e.touches.length === 1) {
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  }

  if (e.touches.length === 2) {
    lastDist = distance(e.touches[0], e.touches[1]);
    lastCenter = center(e.touches[0], e.touches[1]);
  }
}, { passive:false });

// touchmove
canvas.addEventListener('touchmove', (e) => {
  if (!img) return;
  e.preventDefault();

  const { sx, sy } = getCanvasScale();

  // 1 dedo → mover livre
  if (e.touches.length === 1) {
    const dx = (e.touches[0].clientX - lastX) * sx;
    const dy = (e.touches[0].clientY - lastY) * sy;

    offsetX += dx;
    offsetY += dy;

    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;

    render();
  }

  // 2 dedos → zoom + mover
  if (e.touches.length === 2) {
    const newDist = distance(e.touches[0], e.touches[1]);
    const factor = newDist / lastDist;

    scale *= factor;
    scale = Math.max(1, Math.min(3, scale));

    const newCenter = center(e.touches[0], e.touches[1]);
    offsetX += (newCenter.x - lastCenter.x) * sx;
    offsetY += (newCenter.y - lastCenter.y) * sy;

    lastDist = newDist;
    lastCenter = newCenter;

    render();
  }
}, { passive:false });

// download
downloadBtn.addEventListener('click', () => {
  const a = document.createElement('a');
  a.download = 'foto-com-moldura.png';
  a.href = canvas.toDataURL('image/png');
  a.click();
});

frame.onload = render;
render();
</script>

</body>
</html>

